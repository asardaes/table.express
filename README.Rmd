---
output:
    md_document:
        variant: gfm
editor_options: 
  chunk_output_type: console
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, cache = FALSE, include = FALSE}
library(knitr)
library(data.table)
library(table.express)
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    fig.path = "README-",
    cache = FALSE
)
```

[![Travis-CI Build Status](https://travis-ci.org/asardaes/table.express.svg?branch=master)](https://travis-ci.org/asardaes/table.express)
[![AppVeyor Build status](https://ci.appveyor.com/api/projects/status/bb9606tfe648gajn?svg=true)](https://ci.appveyor.com/project/asardaes/table-express)
[![codecov](https://codecov.io/gh/asardaes/table.express/branch/master/graph/badge.svg)](https://codecov.io/gh/asardaes/table.express)


# Table express

Use `dplyr` verbs to build `data.table` expressions.
Check the [vignette](https://asardaes.github.io/table.express/articles/table.express.html) for more information.

## Essence

The basic idea is to parse the input from all the verbs and create a single expression that, after evaluation,
simply delegates all the actual computations to `data.table`,
letting it handle all optimizations as usual.

```{r essence}
# the expression is what matters here, input is left empty
data.table() %>%
    start_expr %>%
    select(col) %>%
    where(var == val) %>%
    order_by(v)
```

The input `data.table` is always assigned in the evaluation's environment as the `.DT_` variable.

In many cases character input can also be supported,
which could be useful for other packages that use `data.table`.
